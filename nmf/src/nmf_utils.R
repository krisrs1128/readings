#! /usr/bin/env Rscript

## File description -------------------------------------------------------------
## Functions that simplify plotting for the different NMF experiments. This is
## separated from nmf_{exper}.R files because we want to use the same code for
## both NMF and zero-inflated NMF.
##
## author: kriss1@stanford.edu

## ---- libraries ----
library("plyr")
library("dplyr")
library("reshape2")
library("ggplot2")
library("ggscaffold")
library("jsonlite")
library("rstan")
library("stringr")
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

## ---- plot-utils ---
#' Plot Contours and Associated Coordinate
#'
#' This is a wrapper of ggcontours in the ggscaffold package that shows the
#' coordinate associated with point clouds.
#'
#' @param plot_data [data.frame] The data frame that contains the sampled
#'   coordinates for the contours, along with the true positions (which will be
#'   indicated with text).
#' @param plot_opts [list] A list specifying plotting appearance. Pretty much
#'   the same as the usual ggcontours plot_opts, except an extra option for plot
#'   limits.
scores_contours <- function(plot_data, plot_opts) {
  p1 <- ggcontours(plot_data, plot_opts) +
    geom_text(
      data = plot_data %>%
        group_by_(.dots = c(plot_opts$group, plot_opts$facet_terms)) %>%
        summarise(mean_1 = mean(value_1), mean_2 = mean(value_2)),
      aes_string(x = "mean_1", y = "mean_2", label = plot_opts$group),
      col = plot_opts$mean_col,
      size = plot_opts$text_size
    ) +
    geom_text(
      data = plot_data %>% filter(iteration == 1),
      aes_string(x = "truth_1", y = "truth_2", label = plot_opts$group),
      size = plot_opts$text_size
    ) +
    scale_x_continuous(limits = plot_opts$x_lim, expand = c(0, 0)) +
    scale_y_continuous(limits = plot_opts$y_lim, expand = c(0, 0))
  p2 <- p1 +
    facet_wrap(formula(paste0("~", plot_opts$group)))
  list("grouped" = p1, "coordinates" = p2)
}

#' Identify a permutation that aligns rows of two matrices
#'
#' One way to get confidence intervals for mixtures on the simplex is
#' to first specify the cluster labels for each component, and then
#' study each of these histograms on their own. This is different
#' from, say, smoothing the mixture distribution and identifying
#' modes.
#'
#' The approach taken here is to find the two rows with maximal
#' correlation and put that in the required permutation. Then, remove
#' those rows and repeat.
#'
#' @param X [numeric matrix] A matrix whose rows we want to align with
#'   X.
#' @param Z [numeric matrix] A matrix whose rows we want to align with
#'   Z.
#' @return pi_result [vector] A permutation such that X[pi_result, ] = Z
#' (ideally).
#' @examples
#' X <- matrix(rnorm(100, mean = 4) ^ 2, 20, 5)
#' pi <- sample(1:20)
#' Z <- X[pi, ] + matrix(rnorm(100), 20, 5)
#' pi_hat <- match_matrix(X, Z)
#' cbind(pi_hat, pi)
match_matrix <- function(X, Z) {
  n <- nrow(X)
  X_tilde <- X
  Z_tilde <- Z

  rownames(X_tilde) <- seq_len(n)
  rownames(Z_tilde) <- seq_len(n)
  pi_result <- rep(0, n)

  for (i in seq_len(n)) {
    # get maximal correlation in remainding rows
    rho <- cor(t(X_tilde), t(Z_tilde))
    max_ix0 <- which(rho == max(rho), arr.ind = TRUE)

    max_ix <- c(
      as.integer(rownames(X_tilde)[max_ix0[1]]),
      as.integer(rownames(Z_tilde)[max_ix0[2]])
    )

    # input to resulting permutation, and update rows
    pi_result[max_ix[2]] <- max_ix[1]
    X_tilde <- X_tilde[-max_ix0[1],, drop = F]
    Z_tilde <- Z_tilde[-max_ix0[2],, drop = F]
  }

  pi_result
}

#' Reshape fitted scores for easy plotting
#'
#' Both thetas and betas in NMF are reshaped using very similar code, so we
#' might as well combine it explicitly in one function.
#'
#' @param samples [array] The samples generated by STAN; e.g. obtained by
#'   fit${param}. Two dimensions are for the actual matrix, the third are from
#'   sampling iterations.
#' @param truth [matrix] The truth parameter values, known because we are
#'   working from a simulation.
#' @param dims [character vector] The names to use for the rows and columns of
#'   the parameter matrix.
#' @return reshaped [data.table] The melted scores, with truth along with samples.
reshape_samples <- function(samples, truth, dims) {
  ## align latent factors (label switchign problem)
  pi_align <- match_matrix(
    t(truth),
    t(apply(samples, c(2, 3), median))
  )
  truth <- truth[, pi_align]

  ## now combine into one df
  reshaped <- samples %>%
    melt(varnames = c("iteration", dims)) %>%
    left_join(
      melt(
        truth,
        varnames = dims,
        value.name = "truth"
      )
    )

  reshaped[, dims[1]] <- factor(
    reshaped[, dims[1]],
    order(truth[, 1])
  )

  reshaped %>%
    setDT() %>%
    dcast.data.table(
      sprintf("%s + iteration ~ %s", dims[1], dims[2]),
      value.var = c("value", "truth")
  )
}

#' Wrapper for reshape_samples, applying to many fits
#'
#' We might want to extract the true and fitted values across several nmf
#' experiments. Each experiment individually would require calling
#' reshape_samples.
#'
#' @param fits [list of paths] A list of paths to the fitted STAN samples. They
#'   will be loaded and the associated samples will be extracted.
#' @param config_path [character] The path to the configuration JSON containing
#'   all the experiment information for these fits. It is assumed that the names
#'   in fits include the (necessarily numerical) IDs specified in this JSON
#'   object.
#' @param param [character] The name of the parameter to extract data for.
#' @param dims [character vector] The names to use for the rows and columns of
#'   the parameter matrix.
#' @param sim_seed [integer] The seed used in simulating the parameter of
#'   interest. This is necessary because we don't read the true values anywhere,
#'   we regenerate the parameter values.
#' @return reshaped [data.table] The same kind of object as the output of
#'   reshape_samples(), except over experiments with multiple configurations.
reshape_all_samples <- function(fits,
                                config_path,
                                param,
                                dims,
                                sim_seed = 01112017) {
  expers <- fromJSON(config_path, simplifyVector = FALSE)

  fit_ids <- str_extract(fits, "[0-9]+")
  exper_ids <- sapply(expers, function(x) { x$id })
  samples <- list()
  for (i in seq_along(fits)) {
    set.seed(sim_seed)
    cur_exper <- expers[[which(exper_ids == fit_ids[[i]])]]
    cur_data <- nmf_sim(cur_exper$sim_opts)

    ## retrieve fitted samples
    samples[[i]] <- reshape_samples(
      get(load(fits[[i]]))[[param]],
      cur_data[[param]],
      dims
    )

    ## join in simulation parameters
    cur_config <- data.frame(c(cur_exper$sim_opts, cur_exper$model_opts))
    samples[[i]] <- cbind(samples[[i]], cur_config)
  }

  rbindlist(samples)
}

#' Melt reshaped samples
#'
#' While for the scatter / contours figures, it's useful to have the dimensions
#' as separate columns, we'll also want to the melted data when computing
#' explicit errors. This takes the output of reshaped_... and melts it so that
#' it's appropriate for histogramming the errors.
#'
#' @param samples [data.frame] The wide samples data, usually the output of
#'   reshape_all_samples.
#' @return melted_samples [data.frame] The same data as samples, but with
#'   different factor dimensions all stacked.
#' @export
melt_reshaped_samples <- function(samples) {
  melted_samples <- samples %>%
    melt(
      variable.name = "dimension",
      value.name = "estimate",
      measure.vars = c("value_1", "value_2")
    ) %>%
    melt(
      variable.name = "truth_dimension",
      measure.vars = c("truth_1", "truth_2"),
      value.name = "truth"
    )

  melted_samples$truth_dimension <- NULL
  melted_samples$dimension <- gsub("value_", "k=", melted_samples$dimension)
  melted_samples
}

#' Errors histogram
#'
#' Plot the histograms of errors associated with the scatterplots from the NMF fits.
#'
#' @param plot_data [data.frame] The data used to plot the error between truth
#'   vs. estimate across all dimensions. See the output of
#'   melt_reshaped_samples().
#' @param facet_terms [character vector] The columns on which to facet_grid the
#'   plot.
#' @param n_bins [int] The number of bins in each histogram panel. Defaults to 75.
#' @param alpha [numeric] The alpha transparency for the different factors.
#' @param colors [character vector] The colors to use for each factor.
#' @return hist_plot [ggplot] The ggplot object showing error histograms across
#'   factors and simulation configurations.
error_histograms <- function(plot_data,
                             facet_terms = NULL,
                             n_bins = 75,
                             alpha = 0.7,
                             colors = c("#d95f02", "#7570b3")) {
  ggplot(mgamma_pois_data) +
    geom_histogram(
      aes(x = sqrt(estimate) - sqrt(truth), fill = dimension, y = ..density..),
      position = "identity", alpha = alpha, bins = n_bins
    ) +
    facet_grid(formula(paste(facet_terms, collapse = "~"))) +
    scale_y_continuous(breaks = scales::pretty_breaks(3)) +
    scale_fill_manual(values = colors) +
    min_theme() +
    theme(
      legend.position = "bottom"
    )
}

## ---- simulation-helpers ----
#' Merge Default NMF options
#'
#' @param opts [list] A partially filled list of options, to fill in with
#'   defaults.
#' @return opts [list] The version of opts with defaults filled in.
merge_nmf_opts <- function(opts = list()) {
  default_opts <- list(
    "K" = 2,
    "N" = 100,
    "P" = 75,
    "a" = 1,
    "b" = 1,
    "c" = 1,
    "d" = 1,
    "zero_inf_prob" = 0
  )
  modifyList(default_opts, opts)
}

#' Simulate NMF Data (optionally zero inflated)
#'
#' To facilitate simulation across many parameters, it's useful to have a single
#' function to generate all the quantities of interest.
#'
#' @param opts [list] A list containing parameters for simulation. Any options
#'   that are not specified will be filled in with defaults, according to
#'   merge_nmf_defaults().
#' @return A list with the latent thetas, betas, mask, and observed Y.
nmf_sim <- function(opts) {
  opts <- merge_nmf_opts(opts)
  attach(opts, warn.conflicts = FALSE)

  ## scores
  theta <- matrix(
    rgamma(N * K, rate = a, shape = b),
    N, K
  )

  ## factors
  beta <- matrix(
    rgamma(P * K, rate = c, shape = d),
    P, K
  )

  ## observations
  y <- matrix(
    rpois(N * P, theta %*% t(beta)),
    N, P
  )

  ## set some proportion to zero
  mask <- matrix(
    sample(
      c(0, 1),
      N * P,
      replace = TRUE,
      prob = c(1 - zero_inf_prob, zero_inf_prob)),
    N, P
  )
  y[mask == 1] <- 0

  list(
    "theta" = theta,
    "beta" = beta,
    "mask" = mask,
    "y" = y
  )
}

## ---- modeling-helpers ----
#' Merge Default Modeling Parameters
#'
#' This lets us run models with partially specified options.
#'
#' @param opts [list] A partially filled list of options, to fill in with
#'   defaults.
#' @return opts [list] The version of opts with defaults filled in.
merge_model_opts <- function(opts = list()) {
  default_opts <- list(
    "inference" = "gibbs",
    "method" = "/scratch/users/kriss1/programming/readings/nmf/src/nmf_gamma_poisson.stan"
  )
  modifyList(default_opts, opts)
}

#' Fit a generic NMF Stan Model
#'
#' This wraps vb() and stan() in the STAN package to let us run either approach
#' using a single command.
#'
#' @param y [matrix] The data on which to fit the NMF model.
#' @param model_opts [list] A partially filled list of model fitting options.
#'   Unspecified options will be passed into merge_model_opts().
#' @param prior_opts [list] A list of prior information, required by the NMF
#'   fitting STAN code.
#' @return result [stan object] The fitted stan object.
fit_model <- function(y, model_opts = list(), prior_opts = list()) {
  stan_data <- list(
    "N" = nrow(y),
    "P" = ncol(y),
    "y" = y
  )
  stan_data <- c(stan_data, prior_opts)

  if (grepl("zero", model_opts$method)) {
    stan_data$zero_inf_prob <- NULL
  }

  if (model_opts$inference == "gibbs") {
    result <- stan(file = model_opts$method, data = stan_data, chain = 1)
  } else if (model_opts$inference == "vb") {
    f <- stan_model(model_opts$method)
    result <- vb(f, stan_data)
  } else {
    stop("model_opts$inference is not recognized")
  }

  extract(result)
}

## ---- batch-helpers ----
#' Write experiment configurations files
#'
#' This generates the JSON file on which all the experiments will be based. It
#' just creates a JSON will the full factorial combinations of input options.
#'
#' @param factors [list] A list of one-dimensional factors on which we compute
#'   the full cross-product.
#' @param path [string] The path to which to save the configurations JSON.
#' @return NULL
#' @side-effects Writes the configurations JSON to path.
#' @examples
#' sim_factors <- list(
#'   "N" = c(50, 100, 200),
#'   "P" = c(75, 125),
#'   "zero_inf_prob" = c(0, 0.2, 0.5, 0.8)
#' )
#' model_factors <- list(
#'   "inference" = c("gibbs", "vb"),
#'   "method" = c("zinf_nmf", "nmf")
#' )
#' #write_configs(sim_factors, model_factors)
write_configs <- function(sim_factors,
                          model_factors,
                          n_batches = 50,
                          config_path = "config.json",
                          output_dir = "./") {
  config_df <- expand.grid(c(sim_factors, model_factors))
  config_df$batch <- rep(seq_len(n_batches), length.out = nrow(config_df))

  config <- vector(length = nrow(config_df), mode = "list")
  sim_ix <- colnames(config_df) %in% names(sim_factors)
  model_ix <- colnames(config_df) %in% names(model_factors)

  ## reshape into a form appropriate for the config json
  for (i in seq_len(nrow(config_df))) {
    config[[i]]$sim_opts <- as.list(config_df[i, sim_ix]) %>%
      merge_nmf_opts()

    config[[i]]$model_opts <- as.list(config_df[i, model_ix]) %>%
      merge_model_opts()

    prior_fields <- c("a", "b", "c", "d", "zero_inf_prob")
    config[[i]]$prior_opts <- config[[i]]$sim_opts[prior_fields]

    config[[i]]$output_dir <- output_dir
    config[[i]]$id <- i
    config[[i]]$batch <- config_df[i, "batch"]
  }

  cat(toJSON(config, auto_unbox = TRUE), file = config_path)
}
